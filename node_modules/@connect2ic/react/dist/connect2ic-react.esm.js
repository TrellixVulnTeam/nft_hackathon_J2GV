import React, { createContext, useState, useEffect, useContext } from 'react';
import { useInterpret, useSelector } from '@xstate/react';
import { connectMachine } from '@connect2ic/core';

const Connect2ICContext = /*#__PURE__*/createContext({});

const Connect2ICProvider = _ref => {
  let {
    children,
    canisters = {},
    whitelist,
    host,
    dev,
    providers,
    autoConnect
  } = _ref;
  const [action, setAction] = useState();
  const connectService = useInterpret(connectMachine, {
    devTools: true,
    actions: {
      onConnect: (context, event) => {
        Object.entries(canisters).forEach(_ref2 => {
          let [canisterName, val] = _ref2;
          const {
            canisterId,
            idlFactory
          } = val;
          connectService.send({
            type: "CREATE_ACTOR",
            data: {
              canisterId,
              idlFactory,
              canisterName
            }
          });
        });
        setAction({
          type: "onConnect",
          context,
          event
        });
      },
      onDisconnect: (context, event) => {
        setAction({
          type: "onDisconnect",
          context,
          event
        });
      },
      onInit: (context, event) => {
        Object.entries(canisters).forEach(_ref3 => {
          let [canisterName, val] = _ref3;
          const {
            canisterId,
            idlFactory
          } = val;
          connectService.send({
            type: "CREATE_ANONYMOUS_ACTOR",
            data: {
              canisterId,
              idlFactory,
              canisterName
            }
          });
        });
      }
    }
  });
  const [open, setOpen] = useState(false);
  const dialog = {
    open: () => setOpen(true),
    close: () => setOpen(false),
    isOpen: open
  };
  useEffect(() => {
    // TODO: on options change?
    connectService.send({
      type: "INIT",
      data: {
        dev,
        whitelist: whitelist !== null && whitelist !== void 0 ? whitelist : Object.values(canisters).map(canister => canister.canisterId),
        host,
        providers,
        autoConnect
      }
    });
  }, [connectService]);
  return /*#__PURE__*/React.createElement(Connect2ICContext.Provider, {
    value: {
      connectService,
      dialog,
      action,
      canisters
    }
  }, children);
};

const useConnect = props => {
  var _connectService$state, _connectService$state2, _connectService$state3, _connectService$state4, _connectService$state5, _connectService$state6, _connectService$state7, _connectService$state8;

  // TODO: handle
  const {
    onConnect = () => {},
    onDisconnect = () => {}
  } = props !== null && props !== void 0 ? props : {};
  const {
    connectService,
    action
  } = useContext(Connect2ICContext);
  const {
    principal,
    activeProvider
  } = useSelector(connectService, state => ({
    principal: state.context.principal,
    activeProvider: state.context.activeProvider
  }));
  useEffect(() => {
    // TODO: Some other workaround? useSelector still has old state when action fires.
    if ((action === null || action === void 0 ? void 0 : action.type) === "onConnect" && activeProvider) {
      onConnect({
        provider: activeProvider
      });
    }

    if ((action === null || action === void 0 ? void 0 : action.type) === "onDisconnect") {
      onDisconnect();
    }
  }, [action, activeProvider]);
  return {
    principal,
    activeProvider,
    isConnected: (_connectService$state = (_connectService$state2 = connectService.state) === null || _connectService$state2 === void 0 ? void 0 : _connectService$state2.matches({
      idle: "connected"
    })) !== null && _connectService$state !== void 0 ? _connectService$state : false,
    isConnecting: (_connectService$state3 = (_connectService$state4 = connectService.state) === null || _connectService$state4 === void 0 ? void 0 : _connectService$state4.matches({
      idle: "connecting"
    })) !== null && _connectService$state3 !== void 0 ? _connectService$state3 : false,
    isDisconnecting: (_connectService$state5 = (_connectService$state6 = connectService.state) === null || _connectService$state6 === void 0 ? void 0 : _connectService$state6.matches({
      idle: "disconnecting"
    })) !== null && _connectService$state5 !== void 0 ? _connectService$state5 : false,
    isIdle: (_connectService$state7 = (_connectService$state8 = connectService.state) === null || _connectService$state8 === void 0 ? void 0 : _connectService$state8.matches({
      idle: "idle"
    })) !== null && _connectService$state7 !== void 0 ? _connectService$state7 : false,
    connect: provider => {
      connectService.send({
        type: "CONNECT",
        data: {
          provider
        }
      });
    },
    disconnect: () => {
      connectService.send({
        type: "DISCONNECT"
      });
    }
  };
};

const useCanister = function (canisterName) {
  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
    mode: "auto" // "anonymous" | "connected"

  };
  const {
    mode
  } = options;
  const {
    connectService
  } = useContext(Connect2ICContext);
  const anonymousActor = useSelector(connectService, state => state.context.anonymousActors[canisterName]);
  const actor = useSelector(connectService, state => state.context.actors[canisterName]);
  const {
    isConnected
  } = useConnect();
  const canister = isConnected && actor && mode !== "anonymous" ? actor : anonymousActor; // TODO:

  const loading = !canister;
  const error = false;
  return [canister, {
    error,
    loading
  }];
};

const useWallet = () => {
  const {
    connectService
  } = useContext(Connect2ICContext);
  const activeProvider = useSelector(connectService, state => state.context.activeProvider); // TODO: kind of hacky

  const supportsWallet = !!(activeProvider !== null && activeProvider !== void 0 && activeProvider.connector.requestTransfer);
  const {
    isConnected
  } = useConnect();
  const wallet = isConnected && supportsWallet ? activeProvider.connector : undefined;
  const loading = false;
  const error = false;
  return [wallet, {
    loading,
    error
  }];
};

const useBalance = () => {
  // TODO: check if supported or not
  const [wallet] = useWallet();
  const [assets, setAssets] = useState();
  const [loading, setLoading] = useState(true); // TODO:

  const [error, setError] = useState(false);

  const refresh = async () => {
    var _wallet$queryBalance;

    if (!wallet) {
      return;
    }

    const result = await ((_wallet$queryBalance = wallet.queryBalance) === null || _wallet$queryBalance === void 0 ? void 0 : _wallet$queryBalance.call(wallet));
    setAssets(result);
    setLoading(false);
  };

  useEffect(() => {
    if (!wallet) {
      setAssets(undefined);
      return;
    }

    refresh();
  }, [wallet]);
  return [assets, {
    loading,
    error,
    refresh
  }];
};

const useDialog = function () {
  const {
    dialog
  } = useContext(Connect2ICContext);
  return dialog;
};

const useProviders = () => {
  const {
    connectService
  } = useContext(Connect2ICContext);
  const providers = useSelector(connectService, state => state.context.initializedProviders);
  return providers !== null && providers !== void 0 ? providers : [];
};

const useSignMessage = _ref => {
  let {
    message
  } = _ref;
  // TODO: check if supported or not
  const [wallet] = useWallet();

  const signMessage = () => {
    var _wallet$signMessage;

    if (!wallet) {
      return;
    }

    (_wallet$signMessage = wallet.signMessage) === null || _wallet$signMessage === void 0 ? void 0 : _wallet$signMessage.call(wallet, {
      message
    });
  };

  const loading = false;
  const error = false;
  return [signMessage, {
    loading,
    error
  }];
};

const useTransfer = _ref => {
  let {
    amount,
    to,
    from = undefined
  } = _ref;
  // TODO: check if supported or not
  const [wallet] = useWallet();
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState();

  const transfer = async () => {
    if (!wallet) {
      return;
    }

    setLoading(true);
    await wallet.requestTransfer({
      amount,
      to,
      from: from !== null && from !== void 0 ? from : wallet.principal
    }).catch(e => {
      setError(e);
    });
    setLoading(false);
  };

  return [transfer, {
    loading,
    error
  }];
};

const ConnectButton = props => {
  const {
    style = {},
    dark = false,
    onConnect = () => {},
    onDisconnect = () => {},
    children
  } = props;
  const dialog = useDialog();
  const {
    disconnect,
    isConnected
  } = useConnect({
    onConnect,
    onDisconnect
  });
  return /*#__PURE__*/React.createElement(React.Fragment, null, !isConnected ? /*#__PURE__*/React.createElement("button", {
    onClick: () => dialog.open(),
    style: style,
    className: "connect-button"
  }, children !== null && children !== void 0 ? children : "Connect") : null, isConnected ? /*#__PURE__*/React.createElement("button", {
    onClick: disconnect,
    style: style,
    className: "connect-button"
  }, children !== null && children !== void 0 ? children : "Disconnect") : null);
};

var ConnectButton$1 = ConnectButton;

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

const ConnectDialog = props => {
  const {
    onClose = () => {
      dialog.close();
    },
    children,
    dark
  } = props;
  const dialog = useDialog();
  const providers = useProviders();
  const {
    connect,
    isConnected
  } = useConnect();
  useEffect(() => {
    if (isConnected) {
      dialog.close();
    }
  }, [isConnected]);
  useEffect(() => {
    if (dialog.isOpen) {
      document.body.style.overflow = "hidden";
    }

    if (!dialog.isOpen) {
      document.body.style.overflow = "unset";
    }
  }, [dialog.isOpen]);
  useEffect(() => {
    const handleEsc = event => {
      if (event.keyCode === 27) {
        dialog.close();
      }
    };

    window.addEventListener("keydown", handleEsc);
    return () => {
      window.removeEventListener("keydown", handleEsc);
    };
  }, []);

  const onClickInside = e => {
    e.stopPropagation();
  };

  return dialog.isOpen ? /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement("div", {
    className: "dialog-styles ".concat(dark ? "dark" : "light"),
    onClick: onClose
  }, /*#__PURE__*/React.createElement("div", {
    onClick: onClickInside,
    className: "dialog-container"
  }, /*#__PURE__*/React.createElement("div", null, providers.map(provider => {
    return /*#__PURE__*/React.createElement("button", _extends({
      key: provider.id,
      onClick: () => connect(provider.id),
      className: "button-styles ".concat(provider.id, "-styles")
    }, props), /*#__PURE__*/React.createElement("img", {
      className: "img-styles",
      src: dark ? provider.icon.dark : provider.icon.light
    }), /*#__PURE__*/React.createElement("div", null, /*#__PURE__*/React.createElement("span", {
      className: "button-label"
    }, provider.name)));
  }))))) : null;
};

var ConnectDialog$1 = ConnectDialog;

export { Connect2ICContext, Connect2ICProvider, ConnectButton$1 as ConnectButton, ConnectDialog$1 as ConnectDialog, useBalance, useCanister, useConnect, useDialog, useProviders, useSignMessage, useTransfer, useWallet };
