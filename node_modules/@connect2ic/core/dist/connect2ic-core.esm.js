import { forwardTo, assign, createMachine } from 'xstate';
import { HttpAgent, Actor } from '@dfinity/agent';

const anonymousActorActions = {
  CREATE_ANONYMOUS_ACTOR: {
    actions: forwardTo("anonymousActorService")
  },
  SAVE_ANONYMOUS_ACTOR: {
    actions: assign((context, event) => ({
      anonymousActors: { ...context.anonymousActors,
        [event.data.canisterName]: event.data.actor
      }
    }))
  }
};
const authStates = {
  id: "auth",
  initial: "initializing",
  schema: {
    context: {},
    events: {}
  },
  states: {
    initializing: {
      on: {
        DONE: {
          target: "idle",
          actions: assign((context, event) => ({
            initializedProviders: event.data.initializedProviders
          }))
        },
        DONE_AND_CONNECTED: {
          target: "connected",
          actions: [assign((context, event) => ({
            initializedProviders: event.data.initializedProviders,
            activeProvider: event.data.activeProvider,
            principal: event.data.principal
          }))]
        },
        ...anonymousActorActions
      },
      invoke: {
        id: "init",
        src: (context, event) => async (callback, onReceive) => {
          // TODO: clean up
          const {
            dev,
            host,
            whitelist
          } = context;
          const initializedProviders = event.data.providers.map(p => ({ ...p,
            connector: new p.connector({
              dev,
              host,
              whitelist
            })
          }));
          await Promise.allSettled(initializedProviders.map(p => p.connector.init()));
          let connectedProviders = initializedProviders.map(p => new Promise(async (resolve, reject) => {
            const isConnected = await p.connector.isConnected();
            isConnected ? resolve(p) : reject();
          }));
          const connectedProviderPromise = Promise.any(connectedProviders);
          connectedProviderPromise.then(connectedProvider => {
            callback({
              type: "DONE_AND_CONNECTED",
              data: {
                initializedProviders,
                activeProvider: connectedProvider,
                principal: connectedProvider.connector.principal
              }
            });
          }).catch(e => {
            // ???
            callback({
              type: "DONE",
              data: {
                initializedProviders
              }
            });
          });
        }
      },
      exit: ["onInit"]
    },
    idle: {
      invoke: {
        id: "connectService",
        autoForward: true,
        src: (context, _event) => (callback, onReceive) => {
          onReceive(async e => {
            // TODO: Handle cancellation with AbortController?
            const provider = context.initializedProviders.find(p => p.id === e.data.provider);

            if (e.type === "CONNECT") {
              try {
                await provider.connector.connect();
                callback({
                  type: "CONNECT_DONE",
                  // TODO: fix?
                  data: {
                    activeProvider: provider,
                    principal: provider.connector.principal
                  }
                });
              } catch (e) {
                callback({
                  // TODO: or cancel?
                  type: "ERROR",
                  data: {
                    error: e
                  }
                });
              }
            }
          });
        }
      },
      on: {
        CONNECT: {
          actions: forwardTo("connectService")
        },
        CONNECT_DONE: {
          target: "connected",
          actions: [assign((context, event) => ({
            activeProvider: event.data.activeProvider,
            principal: event.data.principal
          }))]
        },
        ERROR: {// actions: assign((context, event) => {
          //   return ({
          //     provider: event.data.provider,
          //     principal: event.data.principal,
          //   })
          // }),
        },
        ...anonymousActorActions
      }
    },
    connected: {
      entry: ["onConnect"],
      invoke: {
        id: "actorService",
        src: "actorService",
        autoForward: true
      },
      on: {
        CREATE_ACTOR: {
          actions: forwardTo("actorService")
        },
        DISCONNECT: {
          target: "disconnecting" // TODO: pass provider?

        },
        SAVE_ACTOR: {
          actions: assign((context, event) => ({
            actors: { ...context.actors,
              [event.data.canisterName]: event.data.actor
            }
          }))
        },
        ...anonymousActorActions
      }
    },
    disconnecting: {
      invoke: {
        id: "disconnect",
        src: (context, event) => async () => {
          var _context$activeProvid;

          await ((_context$activeProvid = context.activeProvider) === null || _context$activeProvid === void 0 ? void 0 : _context$activeProvid.connector.disconnect());
        },
        onDone: {
          target: "idle",
          // TODO: empty context
          actions: [assign((context, event) => ({
            activeProvider: undefined
          })), "onDisconnect"]
        },
        onError: {
          target: "connected",
          actions: []
        }
      },
      on: { ...anonymousActorActions
      }
    }
  }
};
const rootMachine = createMachine({
  id: "root",
  initial: "inactive",
  context: {
    host: window.location.origin,
    dev: true,
    autoConnect: true,
    whitelist: [],
    principal: undefined,
    activeProvider: undefined,
    providers: [],
    initializedProviders: [],
    actors: {},
    anonymousActors: {}
  },
  schema: {
    context: {},
    events: {}
  },
  states: {
    inactive: {
      on: {
        INIT: {
          target: "idle",
          actions: assign((context, event) => ({
            whitelist: event.data.whitelist || [],
            host: event.data.host || window.location.origin,
            providers: event.data.providers || [],
            dev: event.data.dev,
            autoConnect: event.data.autoConnect || true
          }))
        }
      }
    },
    idle: { ...authStates,
      invoke: {
        id: "anonymousActorService",
        src: "anonymousActorService"
      }
    }
  }
}, {
  services: {
    anonymousActorService: (context, _event) => (callback, onReceive) => {
      onReceive(async e => {
        if (e.type === "CREATE_ANONYMOUS_ACTOR") {
          const {
            host
          } = context;
          const agent = new HttpAgent({
            host
          }); // Fetch root key for certificate validation during development

          if (context.dev) {
            agent.fetchRootKey().catch(err => {
              console.warn("Unable to fetch root key. Check to ensure that your local replica is running");
              console.error(err);
            });
          }

          const actor = Actor.createActor(e.data.idlFactory, {
            agent,
            canisterId: e.data.canisterId
          });
          callback({
            type: "SAVE_ANONYMOUS_ACTOR",
            data: {
              actor,
              canisterName: e.data.canisterName
            }
          });
        }
      });
    },
    actorService: (context, _event) => (callback, onReceive) => {
      onReceive(async e => {
        if (e.type === "CREATE_ACTOR") {
          const actor = await context.activeProvider.connector.createActor(e.data.canisterId, e.data.idlFactory);
          callback({
            type: "SAVE_ACTOR",
            data: {
              actor,
              canisterName: e.data.canisterName
            }
          });
        }
      });
    }
  }
});

export { rootMachine as connectMachine };
